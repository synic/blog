// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: comments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveComment = `-- name: ApproveComment :one
UPDATE comments SET approved = true WHERE id = $1 RETURNING id, article_slug, user_id, body, created_at, parent_id, approved
`

func (q *Queries) ApproveComment(ctx context.Context, id int64) (Comment, error) {
	row := q.db.QueryRow(ctx, approveComment, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ArticleSlug,
		&i.UserID,
		&i.Body,
		&i.CreatedAt,
		&i.ParentID,
		&i.Approved,
	)
	return i, err
}

const countCommentsBySlug = `-- name: CountCommentsBySlug :many
SELECT article_slug, count(*)::int AS comment_count
FROM comments
WHERE approved = true
GROUP BY article_slug
`

type CountCommentsBySlugRow struct {
	ArticleSlug  string
	CommentCount int32
}

func (q *Queries) CountCommentsBySlug(ctx context.Context) ([]CountCommentsBySlugRow, error) {
	rows, err := q.db.Query(ctx, countCommentsBySlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountCommentsBySlugRow{}
	for rows.Next() {
		var i CountCommentsBySlugRow
		if err := rows.Scan(&i.ArticleSlug, &i.CommentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (article_slug, user_id, body, parent_id, approved)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, article_slug, user_id, body, created_at, parent_id, approved
`

type CreateCommentParams struct {
	ArticleSlug string
	UserID      int64
	Body        string
	ParentID    pgtype.Int8
	Approved    bool
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.ArticleSlug,
		arg.UserID,
		arg.Body,
		arg.ParentID,
		arg.Approved,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.ArticleSlug,
		&i.UserID,
		&i.Body,
		&i.CreatedAt,
		&i.ParentID,
		&i.Approved,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const getCommentWithUser = `-- name: GetCommentWithUser :one
SELECT c.id, c.article_slug, c.body, c.created_at, c.parent_id, c.approved,
       u.username, u.avatar_url, u.email, u.unsubscribe_token, u.unsubscribed
FROM comments c
JOIN users u ON c.user_id = u.id
WHERE c.id = $1
`

type GetCommentWithUserRow struct {
	ID               int64
	ArticleSlug      string
	Body             string
	CreatedAt        pgtype.Timestamptz
	ParentID         pgtype.Int8
	Approved         bool
	Username         string
	AvatarUrl        string
	Email            string
	UnsubscribeToken string
	Unsubscribed     bool
}

func (q *Queries) GetCommentWithUser(ctx context.Context, id int64) (GetCommentWithUserRow, error) {
	row := q.db.QueryRow(ctx, getCommentWithUser, id)
	var i GetCommentWithUserRow
	err := row.Scan(
		&i.ID,
		&i.ArticleSlug,
		&i.Body,
		&i.CreatedAt,
		&i.ParentID,
		&i.Approved,
		&i.Username,
		&i.AvatarUrl,
		&i.Email,
		&i.UnsubscribeToken,
		&i.Unsubscribed,
	)
	return i, err
}

const listCommentsBySlug = `-- name: ListCommentsBySlug :many
SELECT c.id, c.article_slug, c.body, c.created_at, c.parent_id,
       u.username, u.avatar_url
FROM comments c
JOIN users u ON c.user_id = u.id
WHERE c.article_slug = $1 AND c.approved = true
ORDER BY c.created_at ASC
`

type ListCommentsBySlugRow struct {
	ID          int64
	ArticleSlug string
	Body        string
	CreatedAt   pgtype.Timestamptz
	ParentID    pgtype.Int8
	Username    string
	AvatarUrl   string
}

func (q *Queries) ListCommentsBySlug(ctx context.Context, articleSlug string) ([]ListCommentsBySlugRow, error) {
	rows, err := q.db.Query(ctx, listCommentsBySlug, articleSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentsBySlugRow{}
	for rows.Next() {
		var i ListCommentsBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.ArticleSlug,
			&i.Body,
			&i.CreatedAt,
			&i.ParentID,
			&i.Username,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
