// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"
)

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, unsubscribed, unsubscribe_token FROM users WHERE email = $1
`

type GetUserByEmailRow struct {
	ID               int64
	Username         string
	Email            string
	Unsubscribed     bool
	UnsubscribeToken string
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.Unsubscribed,
		&i.UnsubscribeToken,
	)
	return i, err
}

const unsubscribeUser = `-- name: UnsubscribeUser :execrows
UPDATE users SET unsubscribed = true WHERE unsubscribe_token = $1 AND unsubscribed = false
`

func (q *Queries) UnsubscribeUser(ctx context.Context, unsubscribeToken string) (int64, error) {
	result, err := q.db.Exec(ctx, unsubscribeUser, unsubscribeToken)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO users (github_id, username, avatar_url, email)
VALUES ($1, $2, $3, $4)
ON CONFLICT (github_id)
DO UPDATE SET username = EXCLUDED.username, avatar_url = EXCLUDED.avatar_url, email = EXCLUDED.email, updated_at = now()
RETURNING id, github_id, username, avatar_url, created_at, updated_at, email, unsubscribed, unsubscribe_token
`

type UpsertUserParams struct {
	GithubID  int64
	Username  string
	AvatarUrl string
	Email     string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.GithubID,
		arg.Username,
		arg.AvatarUrl,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.Username,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.Unsubscribed,
		&i.UnsubscribeToken,
	)
	return i, err
}
